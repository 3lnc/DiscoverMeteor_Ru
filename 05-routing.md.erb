---
title: Routing
slug: routing
date: 0005/01/01
number: 5
points: 10
photoUrl: http://www.flickr.com/photos/ikewinski/9517814403/
photoAuthor: Mike Lewinski
contents: Learn about routing in Meteor.|Create post discussion pages, with unique URLs.|Learn how to link to those URLs properly.
---

Теперь мы имеем список постов (которые в конце концов отправят пользователи), нам нужна отдельная страница для постов, где наши пользователи смогут обсуждать каждый пост.

Мы бы хотели, чтобы эти страницы были доступны через *постоянную ссылку* (*permalink*) - URL вида `http://myapp.com/posts/xyz` (где `xyz` - идентификатор `_id` в MongoDB), которая уникальна для каждого поста.

Это значит нам понадобится какая-нибудь *маршрутизация* (*routing*), чтобы урл в адресной строке браузера соответствовал правильному контенту страницы. !!!!

### Добавление пакета Iron Router

[Iron Router](https://github.com/EventedMind/iron-router) - это пакет маршрутизации, который был задуман специально для Meteor приложений.

Он помогает не только в маршрутизации (настройке путей), но он может также позаботиться о фильтрации (сопоставление действий к некоторым путям) и даже управлять подписками (контроль, какой путь имеет доступ к этим данным). (Примечание: Iron Router частично был разработан Tom Coleman со-автором книги *Discover Meteor*.)

Во-первых, установим пакет из Atmosphere:

~~~bash
$ mrt add iron-router
~~~
<%= caption "Terminal" %>

Эта команда скачает и установит готовый к использованию пакет iron-router в наше приложение. Обратите внимание, что вам иногда нужно будет перезапустить Meteor приложение (с `ctrl+c` убить процесс, затем `mrt` снова его запустит) перед тем как пакет может быть использован.

Обратите внимание, что Iron Router это сторонний пакет, означающее что вам понадобится Meteorite для его установки (`meteor add iron-router` не будет работать).

<% note do %>

### Словарь маршрутизации

Мы коснёмся большинства различных особенностей маршрутизации в этой главе. Если вы имеете некоторый опыт с фреймворками такими как Rails, вам будут уже знакомы большинство из этих концепций. Но если нет, здесь даётся краткий глоссарий для быстрого ознакомления:

- **Маршруты (routes)**: Маршрут это основной строительный блок маршрутизации. Это в основном набор инструкций, который говорят куда идти и что делать встретив УРЛ (URL).
- **Пути (Paths)**: Путь это УРЛ (URL) внутри вашего приложения. Он может быть статичным (`/terms_of_service`) или динамичным (`/posts/xyz`), и даже включать параметры запроса (`/search?keyword=meteor`).
- **Сегменты (Segments)**: Различные части пути, разделенных прямым слэшем (`/`).
- **Обработчики (Hooks)**: Обработчики это действия, которые вы захотите произвести перед, после, или даже во время процесса маршрутизации. Типичным примером может быть проверка прав пользователя перед отображением страницы.
- **Фильтры (Filters)**: Фильтрами являются простые обработчики, которые вы глобально определяете для одного или нескольких маршрутов.
- **Шаблоны маршрутов (Route Templates)**: Каждому маршруту нужно указать шаблон. Если вы его не укажете маршрут будет смотреть шаблон с таким же именем как и маршрут по умолчанию.
- **Макеты (Layouts)**: Вы можете представить себе макет, как цифровую фото-рамку. Они содержат в себе весь ХТМЛ-код, который оборачивается текущим шаблоном и останется им же, даже если шаблон изменится.
- **Контроллеры (Controllers)**: Иногда, вы будете понимать, что многие ваши шаблоны переиспользуют одни и те же параметры. Взамен дублирования кода, вы можете все эти маршруты наследовать от одного *маршрутного контроллера*, который будет содержать всю логику маршрутизации.

Для большей информации об Iron Router, проверьте [полную документацию на GitHub](https://github.com/EventedMind/iron-router).

<% end %>

### Маршрутизация: Отображение УРЛ-ов На Шаблоны

До сих пор мы делали сборку нашего макета используя «захардкоженные» вставки шаблонов (таких как `{{>postsList}}`). Таким образом, хотя контент нашего приложения может меняться, основная структура страницы всегда одинакова: заголовок со списком постов ниже.

Iron Router позволяет нам уйти от этой плесени взяв на себя рендеринг внутри хтмл-тега `<body>`. Поэтому мы не будем определять содержимое этого тега сами, как мы делали этого с обычной ХТМЛ-страницей. Взамен, мы укажем маршрут к специальному макету, который содержит шаблон-помощника `{{yield}}`.

Этот помощник `{{yield}}` определит специальную динамиеческую зону, которая автоматически будет «рендерить» шаблон соответствующий текущему маршруту (договоримся, отныне эти специальные шаблоны мы будем называть «маршрутными шаблонами» (“route templates”)).

<%= diagram "router-diagram", "Layouts and templates.", "pull-center" %>

Мы начнем с создания нашего макета и добавлением помощника `{{yield}}`. В начале мы удалим наш хтмл-тег `<body>` из `main.html` и переместим его контент в свой шаблон `layout.html`.

Итак наш похудевший `main.html` теперь выглядит так:

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

В то время новосозданный `layout.html` теперь будет содержать внешний макет приложения:

~~~html
<template name="layout">
  <div class="container">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="brand" href="/">Microscope</a>
    </div>
  </header>
  <div id="main" class="row-fluid">
    {{yield}}
  </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>

Как вы можете заметить мы заменили включение шаблона `postsList` вызовом помощника `yield`. Вы заметите, что после этого изменения мы ничего не увидим на экране. Это потому, что мы еще не сказали маршрутизатору что делать с УРЛ-ом `/`, поэтому он просто подаёт пустой шаблон.

Для начала мы можем вернуть наше старое поведение сделав соответствие корневого УРЛ-а `/` к шаблону `postsList`. Мы создадим каталог `/lib` в корне нашего проекта, а внутри создадим `router.js`:

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js"%>

Мы сделали две вашные вещи. Во-первых, мы сказали маршрутизатору использовать макет, который мы просто создали как макет по-умолчанию для всех маршутов. Во-вторых,  мы определили новый маршрут называемый `postsList` и отображенный на путь `/`.

<% note do %>

### Папка `/lib`

Что угодно положенное в папку `/lib` гарантированно загрузится первым, прежде чем всё остальное в вашем приложении (за возможным исключением умных пакетов). Это делает эту папку отличным место для любого вспомогательного кода, который нужен доступным всё время.

Небольшое предупреждение: заметим что поскольку папки `/lib` нет внутри папок `/client` или `/server` это означать что её контент будет доступен для обоих окружений.

<% end %>

### Named Routes

////

////

////

////

~~~html
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### Waiting on Data

////

////

////

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

////

////

////

////

////

////

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

////

<%= commit "5-2", "Wait on the post subscription." %>

<% note do %>

### A First Glance At Reactivity

////

////

////

<% end %>

### Routing To A Specific Post

////

////

////

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

////

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

////

////

////

////

<%= diagram "router-diagram-2", "The data context.", "pull-center" %>

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

////

////

<% note do %>

### More About Data Contexts

////

////

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

////

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

////

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Using a Dynamic Named Route Helper

////

////

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

////

////

////

////

////

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

////

////

////

<% end %>