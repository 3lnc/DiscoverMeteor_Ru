---
title: Маршрутизация (Routing)
slug: routing
date: 0005/01/01
number: 5
points: 10
photoUrl: http://www.flickr.com/photos/ikewinski/9517814403/
photoAuthor: Mike Lewinski
contents: Изучите маршрутизацию в Meteor.|Создадите страницы обсуждения постов с уникальными URL-ми.|Изучите как соединять с такими URL-ми правильно.
---

Теперь, когда мы имеем список постов (которые в конце концов отправят пользователи), нам нужна отдельная страница для каждого поста, где наши пользователи смогут обсудить его.

Мы бы хотели, чтобы эти страницы были доступны через *постоянную ссылку* (*permalink*) -- URL вида `http://myapp.com/posts/xyz` (где `xyz` - идентификатор `_id` в MongoDB), которая уникальна для каждого поста.

Это значит нам понадобится какая-нибудь *маршрутизация (routing)*, чтобы адресная строка в браузере правильно соответствовала отображаемому контенту.

### Добавление пакета Iron Router

[Iron Router](https://github.com/EventedMind/iron-router) - это пакет маршрутизации, который был задуман специально для Meteor приложений.

Он помогает не только в маршрутизации (настройке путей), но он может также позаботиться о фильтрации (сопоставление действий к некоторым путям), и даже управлять подписками (контролировать, какой путь имеет доступ к этим данным). (Примечание: Iron Router частично был разработан Tom Coleman соавтором книги *Discover Meteor*.)

Во-первых, установим пакет из Atmosphere:

~~~bash
$ mrt add iron-router
~~~
<%= caption "Terminal" %>

This command downloads and installs the iron-router package into our app, ready to use. Note that you might sometimes need to restart your Meteor app (with `ctrl+c` to kill the process, then `mrt` to start it again) before a package can be used.

Обратите внимание, что Iron Router это сторонний пакет, поэтому вам понадобится Meteorite для его установки (`meteor add iron-router` не будет работать).

<% note do %>

### Термины Маршрутизации

В этой главе мы коснёмся большинства различных особенностей маршрутизации. Если вы имеете некоторый опыт с фреймворками такими как Rails, вам будут уже знакомы большинство из этих концепций. Но если это не так, здесь приводится краткий словарик для быстрого ознакомления:

- **Маршруты (Routes)**: Основной строительный блок маршрутизации. Это в основном набор инструкций, которые говорят куда идти и что делать при встрече с данным URL-ом.
- **Пути (Paths)**: URL внутри вашего приложения. Он может быть статичным (`/terms_of_service`) или динамичным (`/posts/xyz`), и даже включать параметры запроса (`/search?keyword=meteor`).
- **Сегменты (Segments)**: Различные части пути, разделенные прямым слэшем (`/`).
- **Обработчики (Hooks)**: Действия, которые вы захотите произвести перед, после, или даже во время процесса маршрутизации. Типичным примером может быть проверка прав пользователя перед отображением страницы.
- **Фильтры (Filters)**: Простые обработчики, которые вы глобально определяете для одного или нескольких маршрутов.
- **Шаблоны маршрутов (Route Templates)**: Каждому маршруту нужно указать шаблон. Если вы его не укажете маршрутизатор будет искать шаблон с таким же именем как у маршрута по умолчанию.
- **Макеты (Layouts)**: Вы можете думать о макетах, как о цифровых фоторамках. Они содержат в себе весь html-код, который оборачивается текущим шаблоном, и будут оставаться ими же, даже если шаблон изменится.
- **Контроллеры (Controllers)**: Иногда, вы будете понимать, что многие ваши шаблоны переиспользуют одни и те же параметры. Взамен дублирования кода, вы можете все эти маршруты наследовать от одного *маршрутного контроллера (routing controller)*, который будет содержать всю логику маршрутизации.

Для более подробной информации об Iron Router смотрите [полную документацию на GitHub](https://github.com/EventedMind/iron-router).

<% end %>

### Маршрутизация: Сопоставление URL-ов С Шаблонами

До сих пор мы делали сборку нашего макета используя жёстко заданные вставки шаблонов (такие как `{{>postsList}}`). Таким образом контент нашего приложения может меняться, но основная структура страницы всегда одинакова: заголовок со списком постов ниже.

Iron Router позволяет нам убежать от этой замшелости взятием на себя рендеринга внутри html-тега `<body>`. Поэтому мы не будем определять содержимое этого тега сами, как мы делали этого с обычной html-страницей. Взамен, мы укажем маршрут к специальному макету, который содержит метод шаблона `{{yield}}`.

Этот `{{yield}}` метод определит специальную динамическую зону, которая автоматически будет «рендерить» шаблон соответствующий текущему маршруту (договоримся, с этого места такие специальные шаблоны мы будем называть «маршрутными шаблонами» (“route templates”)):

<%= diagram "router-diagram", "Layouts and templates.", "pull-center" %>

Мы начнем с создания нашего макета и добавлением метода `{{yield}}`. В начале мы удалим наш html-тег `<body>` из `main.html` и переместим его контент в свой шаблон `layout.html`.

Итак наш похудевший `main.html` теперь выглядит так:

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

В то время новосозданный `layout.html` теперь будет содержать внешний макет приложения:

~~~html
<template name="layout">
  <div class="container">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="brand" href="/">Microscope</a>
    </div>
  </header>
  <div id="main" class="row-fluid">
    {{yield}}
  </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>

Как вы можете заметить мы заменили включение шаблона `postsList` вызовом метода `yield`. Вы заметите, что после этого изменения мы ничего не увидим на экране. Это потому, что мы еще не сказали маршрутизатору что делать с URL-ом `/`, поэтому он просто выдаёт пустой шаблон.

Для начала мы можем вернуть наше старое поведение сделав соответствие корневого URL-а `/` к шаблону `postsList`. Мы создадим каталог `/lib` в корне нашего проекта, а внутри создадим `router.js`:

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js"%>

Мы сделали две важные вещи. Во-первых, мы сказали маршрутизатору использовать макет, который мы просто создали как макет по-умолчанию для всех маршутов. Во-вторых, мы определили новый маршрут называемый `postsList` и отображенный на путь `/`.

<% note do %>

### Папка `/lib`

Что угодно положенное в папку `/lib` гарантированно загрузится первым, прежде чем всё остальное в вашем приложении (за возможным исключением умных пакетов). Это делает папку `/lib` отличным место для любого вспомогательного кода, который нужен доступным всё время.

Небольшое предупреждение: заметим что поскольку папки `/lib` нет внутри папок `/client` или `/server` это означает что её контент будет доступен для обоих окружений.

<% end %>

### Именованные Маршруты

Проясним здесь некоторые моменты. Мы назвали наш маршрут `postsList`, но мы также назвали *шаблон* -- `postsList`. И что же здесь происходит?

По умолчанию Iron Router ищет шаблон с таким же именем как и маршрут. По факту он будет даже искать *путь (path)* основанный на имени маршрута, это означает, что мы не определив свой путь (который мы указываем опцией `path` в нашем описании маршрута), сделали наш шаблон по умолчанию доступным по URL `/postsList`.

Вам может быть интересно, почему нам вообще нужно давать имя нашим маршрутам. Именованные маршруты позволят нам использовать несколько особенностей Iron Router чтобы облегчить создание ссылок внутри приложения. Один из самых полезных методов в Handlebars - это `{{pathFor}}`, который возвращает компонент URL путь любого маршрута.

Мы хотим, чтобы наша ссылка на главную страницу указывала на список постов. Вместо того чтобы определить статический URL `/` мы можем также использовать метод в Handlebars. Конечный результат будет такой же, но это даст нам больше гибкости так как этот метод будет всегда выводить правильный URL даже если мы изменим путь маршрута в маршрутизаторе.

~~~html
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### В Ожидании Данных

Если вы проведете развертывание текущей версии приложения (или запустите экземпляр используя ссылку выше), вы заметите что перед списком постов некоторое время отображается пустой список. Это потому что вначале загрузки страницы нет постов для отображения до тех пор пока подписчик `posts` не закончит забирать данные с сервера.

Было бы намного лучше для взаимодействия с пользователем обеспечить визуальную обратную связь чего-то происходящего.

К счастью, Iron Router даёт нам простой способ сделать это -- мы воспользуемся подписчиком `waitOn`:

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

Разберемся с этим кодом. Во-первых, мы изменили блок `Router.configure()` обеспечив маршрутизатор именем загрузочного шаблона (который мы скоро создадим) для перенаправления на него пока наше приложение ожидает данные.

Во-вторых, мы также добавили функцию `waitOn`, которая возвращает нашу `posts` подписку. Это означает, что маршрутизатор будет гарантировать то, что подписка `posts` подгрузится перед отправкой пользователя по маршуруту, который он запросил.

Заметим, что поскольку мы определяем нашу функцию `waitOn` глобально на уровне маршрутизации, она сработает тогда когда пользователь впервые зайдёт в ваше приложение. После этого данные уже будут загружены в память браузера и маршрутизатору не нужно будет ждать их снова.

А так как мы сейчас позволили маршрутизатору обрабатывать нашу подписку, вы теперь можете безопасно удалить её из `main.js` (который теперь будет пустым).

Это как правило хорошая идея ожидать ваши подписки, не просто только для взаимодействия с пользователем, но и также потому что это означает что вы можете с уверенностью предположить что данные всегда будут доступны в шаблоне. Это устраняет необходимость иметь дело с шаблонами начинающие рендеринг перед тем как их базовые данные будут доступны, которые часто требуют хитрые обходные пути.

Финальный кусочек головоломки это актуальный шаблон процесса загрузки. Для создания прекрасного анимированного индикатора загрузки мы воспользуемся пакетом `spin`. Добавим его с `mrt add spin`, и потом создадим шаблон `loading`:

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

Заметьте что `{{>spinner}}` частично содержится в `spin` пакете. Даже если эта часть приходит “извне” нашего приложения, мы можем вставлять его также как и любой другой шаблон.

<%= commit "5-2", "Wait on the post subscription." %>

<% note do %>

### Первый Взгляд на Реактивность

Реактивность это базовая часть Meteor, и хотя мы еще по настоящему не касались её, наш шаблон загрузки даёт первый взгляд на эту концепцию.

Перенаправление на шаблон загрузки пока данные еще не загружены это конечно же хорошо, но как маршрутизатор узнал, что как только данные поступят тогда перенаправить пользователя *обратно* на правильную страницу?

На данный момент, скажем просто, что это однозначно работает реактивность. Но не беспокойтесь, вы скоро изучите её.

<% end %>

### Маршрутизация к указанному посту

Now that we've seen how to route to the `postsList` template, let's set up a route to display the details of a single post. 

There's just one catch: we can't go ahead and define one route per post, since there might be hundreds of them. So we'll need to set up a single *dynamic* route, and make that route display any post we want. 

To start with, we'll create a new template that simply renders the same post template that we used earlier in the list of posts.

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

We'll add more elements to this template later on (such as comments), but for now it'll simply serve as a shell for our `{{> postItem}}` include. 

We are going to create another named route, this time mapping URL paths of the form `/posts/<ID>` to the `postPage` template:

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

The special `:_id` syntax tells the router two things: first, to match any route of the form `/posts/xyz/`, where “xyz” can be anything at all. Second, to put whatever it finds in this “xyz” spot inside an `_id` property in the router's `params` array. 

Note that we're only using `_id` for convenience's sake here. The router has no way of knowing if you're passing it an actual `_id`, or just some random string of characters. 

We're now routing to the correct template, but we're still missing something: the router knows the `_id` of the post we'd like to display, but the template still has no clue. So how do we bridge that gap?

Thankfully, the router has a clever built-in solution: it lets you specify a template's **data context**. You can think of the data context as the filling inside a delicious cake made of templates and layouts. Simply put, it's what you fill up your template with:

<%= diagram "router-diagram-2", "The data context.", "pull-center" %>

In our case, we can get the proper data context by looking for our post based on the `_id` we got from the URL: 

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

So every time a user accesses this route, we'll find the appropriate post and pass it to the template. Remember that `findOne` returns a single post that matches a query, and that providing just an `id` as an argument is a shorthand for `{_id: id}`. 

Within the `data` function for a route, `this` corresponds to the currently matched route, and we can use `this.params` to access the named parts of the route (which we indicated by prefixing them with `:` inside our `path`).

<% note do %>

### More About Data Contexts

By setting a template's *data context*, you can control the value of `this` inside template helpers.

This is usually done implicitly with the `{{#each}}` iterator, which automatically sets the data context of each iteration to the item currently being iterated on:

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

But we can also do it explicitly using `{{#with}}`, which simply says "take this object, and apply the following template to it". For example, we can write:

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

It turns out you can achieve the same result by passing the context as an *argument* to the template call. So the previous block of code can be rewritten as:

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Using a Dynamic Named Route Helper

Finally, we need to make sure that we're pointing to the right place whevener we want to link to an individual post. Again, we could do something like `<a href="/posts/{{_id}}">`, but using a route helper is just more reliable. 

We've named the post route `postPage`, so we can use a `{{pathFor 'postPage'}}` helper:

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

But wait, how exactly does the router know where to get the `xyz` part in `/posts/xyz`? After all, we're not passing it any `_id`. 

It turns out that Iron Router is smart enough to figure it out by itself. We're telling the router to use the `postPage` route, and the router knows that this route requires an `_id` of some kind (since that's how we defined our `path`) .

So the router will look for this `_id` in the most logical place available: the data context of the `{{pathFor 'postPage'}}` helper, in other words `this`. And it so happens that our `this` corresponds to a post, which (surprise!) does possess an `_id` property. 

Alternatively, you can also explicitely tell the router where you'd like it to look for the `_id` property, by passing a second argument to the helper (i.e. `{{pathFor 'postPage' someOtherPost}}`). A practical use of this pattern would be getting the link to the previous or next posts in a list, for example. 

To see if it works correctly, browse to the post list and click on one of the 'Discuss' links. You should see something like this:

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

One thing to realise is that these URL changes are happening using [HTML5 pushState](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history?redirectlocale=en-US&redirectslug=Web%2FGuide%2FDOM%2FManipulating_the_browser_history). 

The Router picks up clicks on URLs that are internal to the site, and prevents the browser from browsing away from the app, instead just making the necessary changes to the app's state. 

If everything is working correctly the page should change instantaneously. In fact, sometimes things change so fast that some kind of page transition might be needed. This is outside of the scope of this chapter, but an interesting topic nonetheless.

<% end %>