---
title: Разбиение на страницы
slug: pagination
date: 0012/01/01
number: 12
contents: Узнаете больше о подписках Meteor, и как мы можем их использовать для контроля данных.|Создадите страницу с подгружаемыми данными по мере прокрутки.|Используете пакет `iron-router-progress` для создания индикатора в стиле iOS.|Создадите особенную подписку для прямых линков на страницу постов.
paragraphs: 67
---

Наше приложение Microscope продвигается ударными темпами, и оно определенно станет хитом когда мы его запустим.

По этой причине стоит задуматься о быстродействии приложения, и о том как оно пострадает когда сотни и тысячи пользователей ринутся создавать новые посты.

Ранее мы говорили о том, как коллекция на клиенте должна хранить только часть данных, доступных на сервере. Мы даже создали такие коллекции для уведомлений и комментариев.

Не смотря на это мы все еще публикуем все наши посты за раз, для всех подключенных пользователей. Когда количество постов станет измеряться тысячами, это станет большой проблемой. Чтобы избежать ее, нам надо начать разбивать посты на отдельные страницы.

### Добавляем больше постов

Для начала давайте создадим больше тестовых постов, чтобы было что разбивать на страницы.

~~~js
// Fixture data
if (Posts.find().count() === 0) {

  //...

  Posts.insert({
    title: 'The Meteor Book',
    userId: tom._id,
    author: tom.profile.name,
    url: 'http://themeteorbook.com',
    submitted: now - 12 * 3600 * 1000,
    commentsCount: 0
  });

  for (var i = 0; i < 10; i++) {
    Posts.insert({
      title: 'Test post #' + i,
      author: sacha.profile.name,
      userId: sacha._id,
      url: 'http://google.com/?q=test-' + i,
      submitted: now - i * 3600 * 1000,
      commentsCount: 0
    });
  }
}
~~~
<%= caption "server/fixtures.js" %>
<%= highlight "15~24" %>

После запуска команды `meteor reset` вы должны получить примерно такую картину:

<%= screenshot "12-1", "Displaying dummy data. " %>

<%= commit "12-1", "Добавили достаточно постов чтобы их можно было разбивать на страницы." %>

### Бесконечные страницы

В лучших традициях современных веб-приложений мы создадим механизм, который будет подгружать новые посты по мере прокрутки страницы вниз. Для начала мы загрузим, скажем, 10 постов, а внизу высветим ссылку "Загрузить еще". По щелчку на этой ссылке мы подгрузим еще 10 постов, и так *до бесконечности*. Таким образом мы сможем контролировать всю нашу систему разбиения данных на страницы с помощью одного единственного параметра, означающего количество постов, единовременно выводимых на экран.

Нам надо придумать способ сообщить об этом параметру серверу, чтобы тот знал, сколько постов засылать клиенту. У нас уже есть подписка на публикацию `posts` на маршрутизаторе. Мы воспользуемся ей, чтобы дать маршрутизатору возможность управлять нашими страницами.

Самый простой способ передать параметр на сервер будет через URL. Например, в таком формате - `http://localhost:3000/25` - здесь мы передаем значение `25`, про которое сервер догадается, что оно означает количество постов. Дополнительной фишкой будет то, что если пользователь случайно (или намеренно) перезагрузит страницу в браузере, он снова получит то же самое количество постов, что и ранее.

Для этого нам понадобится изменить способ подписки на посты. Точно так же, как и в главе *Комментарии*, мы переместим код подписки с уровня *маршрутизатора* на уровень *маршрута*.

Если вы уже запутались - не пугайтесь. Сейчас все станет яснее, когда мы начнем писать код.

Для начала мы уберем подписку на публикацию `posts` в блоке `Router.configure()`. Удалите `Meteor.subscribe('posts')`, и оставьте только подписку на уведомления - `notifications`:

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() {
    return [Meteor.subscribe('notifications')]
  }
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "5" %>

Затем мы добавим параметр `postsLimit` в адрес маршрута. Символ `?` означает, что параметр необязательный. Таким образом наш маршрут будет совпадать не только с `http://localhost:3000/50`, но и с обычным `http://localhost:3000`.

~~~js
Router.map(function() {
  //...

  this.route('postsList', {
    path: '/:postsLimit?'
  });
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "5" %>

Стоит особенно отметить что маршрут в виде `/:parameter?` будет совпадать со всеми возможными маршрутами. Так как каждый маршрут будет последовательно проверен на совпадение с текущим адресом, стоит уделить особенное внимание объявлению маршрутов в порядке уменьшения конкретности.

Другими словами, более точные маршруты вроде `/posts/:id` должны быть объявлены в начале, а наш маршрут `postsList` стоит переместить ближе к концу файла, так как он будет совпадать практически с любым адресом.

Настало время бросить вызов серьезной проблеме подписки и нахождения верных данных. Определим значение по-умолчанию для случая когда параметр `postsLimit` отсутствует. Пусть это будет "5" - такое значение позволит нам сгенерировать множество страниц для листа постов.

~~~js
Router.map(function() {
  //..

  this.route('postsList', {
    path: '/:postsLimit?',
    waitOn: function() {
      var postsLimit = parseInt(this.params.postsLimit) || 5;
      return Meteor.subscribe('posts', {sort: {submitted: -1}, limit: postsLimit});
    }
  });
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "6~9" %>

Обратите внимание как мы передаем JavaScript объект ({limit: postsLimit}) вместе с именем нашей публикации `posts`. Этот объект послужит параметром `options`, когда сервер вызовет `Posts.find()` чтобы получить порцию постов. Давайте переключимся на код сервера и воплотим это:

~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});

Meteor.publish('comments', function(postId) {
  return Comments.find({postId: postId});
});

Meteor.publish('notifications', function() {
  return Notifications.find({userId: this.userId});
});
~~~
<%= caption "server/publications.js" %>
<%= highlight "1~3" %>

<% note do %>

### Передаем параметры

Наш код публикаций в свою очередь сообщает серверу, что он может доверять всем объектам JavaScript, которые посылает клиент (в нашем случае, `{limit: postsLimit}`). Доверие сервера настолько велико, что он может использовать этот объект в качестве параметра вызова `find()`. Это позволяет пользователям посылать любые опции запроса через консоль браузера.

В нашем случае это вполне безобидно, так как все что пользователь может сделать это поменять посты местами, или изменить значение параметра `limit`.

Подобного подхода стоит избегать, когда у объектов есть секретные неопубликованные поля с данными частного характера. Пользователь запросто сможет получить данные из этих полей, добавив их в объект запроса. По той же причине объект запроса не стоит использовать напрямую как параметр вызова `find()`.

Безопаснее будет передавать отдельные параметры вместо целого объекта - чтобы избежать передачи ненужных полей:

~~~js
Meteor.publish('posts', function(sort, limit) {
  return Posts.find({}, {sort: sort, limit: limit});
});
~~~

<% end %>

Теперь, когда мы подписываемся на данные на уровне маршрутизатора, стоит установить контекст данных. Мы слегка изменим наш традиционный подход, заставив функцию `data` вернуть объект JavaScript вместо курсора на данные в Mongo. Это позволит создать именной контекст данных, который мы назовем `posts`.

Традиционно контекст данных был доступен как `this` внутри шаблона, но теперь он будет доступен через `posts`. В остальном, следующий код должен быть уже знаком:

~~~js
Router.map(function() {
  this.route('postsList', {
    path: '/:postsLimit?',
    waitOn: function() {
      var limit = parseInt(this.params.postsLimit) || 5;
      return Meteor.subscribe('posts', {sort: {submitted: -1}, limit: limit});
    },
    data: function() {
      var limit = parseInt(this.params.postsLimit) || 5;
      return {
        posts: Posts.find({}, {sort: {submitted: -1}, limit: limit})
      };
    }
  });

  //..
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "8~13" %>

Теперь когда мы задаем контекст данных на уровне маршрутизатора, можно окончательно избавиться от хелпера шаблона `posts` в файле `posts_list.js`. И так как мы назвали наш контекст `posts` (точно так же, как и хелпер), нам даже не нужно трогать шаблон `postsList`.

Файл маршрутизатора `router.js` теперь должен выглядеть так:

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() {
    return [Meteor.subscribe('notifications')]
  }
});

Router.map(function() {
  //...

  this.route('postsList', {
    path: '/:postsLimit?',
    waitOn: function() {
      var limit = parseInt(this.params.postsLimit) || 5;
      return Meteor.subscribe('posts', {sort: {submitted: -1}, limit: limit});
    },
    data: function() {
      var limit = parseInt(this.params.postsLimit) || 5;
      return {
        posts: Posts.find({}, {sort: {submitted: -1}, limit: limit})
      };
    }
  });
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "5, 11~21" %>

<%= commit "12-2", "Поправили маршрут postsList чтобы он работал с параметром limit." %>

Давайте опробуем нашу новенькую систему разбития результатов на страницы в действии. Изменяя параметр в URL мы можем задавать количество постов, выводимых на одну страницу. Попробуйте открыть `http://localhost:3000/3`. Вы должны увидеть что-то вроде такого:

<%= screenshot "12-2", "Контролируем количество постов на главной странице. " %>

<% note do %>

### Почему не отдельные страницы?

Почему мы решили подгружать новые посты по мере прокрутки, а не отдельные страницы по 10 постов на каждой? Ведь так, например, делает Google. Все дело в природе реального времени, на которой построен Meteor.

Давайте представим что мы разбиваем коллекцию `Posts` на страницы, как это делает Google с результатами поиска. Мы перешли на вторую страницу, которая высвечивает посты с 10 по 20. Что произойдет, если другой пользователь удалит любой из предыдущих 10 постов?

Так как наше приложение работает в реальном времени, наши данные тут же изменятся. Пост номер 10 превратится в 9 и пропадет со страницы, в то время как пост номер 11 займет его место. В конце-концов результатом окажется то, что на глазах у пользователя посты поменяют места без видимой на то причины.

Даже если бы наш UX дизайн перетерпел бы подобное поведение интерфейса, традиционное разбиение на страницы вовсе нетривиально в техническом воплощении.

Вернемся к предыдущему примеру. Мы опубликовали посты от 10 до 20 из коллекции `Posts`, но как же вы найдете эти посты на клиенте? Вы не можете выбрать посты от 10 до 20, так как их всего 10 в коллекции на клиенте.

Одним из решений было бы опубликовать эти 10 постов на сервере, и затем вызвать `Posts.find()` на клиенте чтобы собрать *все* опубликованные посты.

Это сработает только если у вас одна единственная подписка. Но что если у вас появится больше одной подписки на посты, как у нас вскоре и произойдет?

Представим что одна подписка запрашивает посты от 10 до 20, а вторая от 30 до 40. Теперь у вас загружено 20 постов на клиенте, и ни малейшего представления какой из постов принадлежит которой подписке.

Из-за всех этих причин традиционный способ разбиения коллекций на страницы плохо работает вместе с Meteor.

<% end %>

### Создаем Контроллер для Маршрутизатора

Вы могли заметить что мы дважды повторили линию кода `var limit = parseInt(this.params.postsLimit) || 5;`. Вдобавок, использование предопределенных величин в коде вроде этой цифры "5" является плохой практикой. Мир от этого не рухнет, но код стоит немного прооптимизировать согласно принципам DRY - Don't Repeat Yourself - "Не повторяйтесь".

Открываем новую сторону маршрутизатора Iron Router - *Контроллер Маршрутизатора* - *Route Controller*. Это удобный способ сгруппировать несколько фишек маршрутизатора в один пакет, который легко подключается к любому маршрутизатору. В этот раз мы используем его для одного единственного маршрута, но уже в следующей главе вы увидите, насколько он облегчит нам жизнь.

~~~js
PostsListController = RouteController.extend({
  template: 'postsList',
  increment: 5,
  limit: function() {
    return parseInt(this.params.postsLimit) || this.increment;
  },
  findOptions: function() {
    return {sort: {submitted: -1}, limit: this.limit()};
  },
  waitOn: function() {
    return Meteor.subscribe('posts', this.findOptions());
  },
  data: function() {
    return {posts: Posts.find({}, this.findOptions())};
  }
});

Router.map(function() {
  //...

  this.route('postsList', {
    path: '/:postsLimit?',
    controller: PostsListController
  });
});
~~~
<%= caption "lib/router.js" %>

Рассмотрим код. Сначала мы создали контроллер наследуя его от `RouteController`. Затем был инициализирован параметр `template`, а также новый параметр - `increment`.

Дальше мы задали функцию `limit` которая вернет значение текущего ограничения на количество постов на странице. Функция `findOptions` возвращает объект с параметрами поиска. Возможно, сейчас она вам покажется лишней, но уже скоро она нам понадобится.

Затем мы определили функции `waitOn` и `data` - теперь они используют нашу функцию `findOptions`.

Напоследок через параметр `controller` мы сообщили маршруту `postsList` использовать наш новый контроллер.

<%= commit "12-3", "Изменили маршрут postsLists чтобы он перенаправлял на контроллер маршрутизатора." %>

### Добавляем линк для загрузки следующей страницы постов

Разбиение на страницы работает, и наш код выглядит просто отлично. Осталась одна проблема - переход по страницам пока что работает только если вы вручную будете менять параметр номера страницы в адресной строке. Давайте сделаем все чуть проще и приятнее в использовании.

Нам понадобится кнопка в конце листа с постами - "Загрузить еще постов". Каждый раз когда пользователь ее кликнет, количество постов на странице увеличится на 5. Если наш текущий URL `http://localhost:3000/5`, кликание на кнопке должно изменить его на `http://localhost:3000/10`.

Как и ранее, мы добавим логику разбиения на страницы в маршрут. Помните как мы передали контекст данных именной переменной, вместо того чтобы использовать анонимный курсор? Точно так же не существует правила, по которому функция `data` может передавать одни курсоры. Мы воспользуемся той же техникой чтобы сгенерировать URL для кнопки "Загрузить еще постов".

~~~js
PostsListController = RouteController.extend({
  template: 'postsList',
  increment: 5,
  limit: function() {
    return parseInt(this.params.postsLimit) || this.increment;
  },
  findOptions: function() {
    return {sort: {submitted: -1}, limit: this.limit()};
  },
  waitOn: function() {
    return Meteor.subscribe('posts', this.findOptions());
  },
  posts: function() {
    return Posts.find({}, this.findOptions());
  },
  data: function() {
    var hasMore = this.posts().fetch().length === this.limit();
    var nextPath = this.route.path({postsLimit: this.limit() + this.increment});
    return {
      posts: this.posts(),
      nextPath: hasMore ? nextPath : null
    };
  }
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "16~23" %>

////

////

////

////

////

////

////

////

////

////

~~~html
<template name="postsList">
  <div class="posts">
    {{#each posts}}
      {{> postItem}}
    {{/each}}

    {{#if nextPath}}
      <a class="load-more" href="{{nextPath}}">Load more</a>
    {{/if}}
  </div>
</template>
~~~
<%= caption "client/views/posts/posts_list.html" %>
<%= highlight "7~10" %>

////

<%= screenshot "12-3", "The “load more” button. " %>

<%= commit "12-4", "Added nextPath() to the controller and use it to step through posts." %>

<% note do %>

### Count vs Length

////

<% end %>

### A Better Progress Bar

////

////

////

~~~bash
mrt add iron-router-progress
~~~
<%= caption "bash console" %>

////

////

~~~js
Router.map(function() {

  //...

  this.route('postSubmit', {
    path: '/submit',
    disableProgress: true
  });
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "7" %>

<%= commit "12-5", "Use the iron-router-progress package to make pagination nicer." %>

### Accessing Any Post

////

<%= screenshot "12-4", "An empty template." %>

////

////

////

~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});

Meteor.publish('singlePost', function(id) {
  return id && Posts.find(id);
});
~~~
<%= caption "server/publications.js" %>
<%= highlight "5~7" %>

////

~~~js
Router.map(function() {

  //...

  this.route('postPage', {
    path: '/posts/:_id',
    waitOn: function() {
      return [
        Meteor.subscribe('singlePost', this.params._id),
        Meteor.subscribe('comments', this.params._id)
      ];
    },
    data: function() { return Posts.findOne(this.params._id); }
  });

  this.route('postEdit', {
    path: '/posts/:_id/edit',
    waitOn: function() {
      return Meteor.subscribe('singlePost', this.params._id);
    },
    data: function() { return Posts.findOne(this.params._id); }
  });

  /...

});
~~~
<%= caption "lib/router.js" %>
<%= highlight "7~12,18~20" %>

<%= commit "12-6","Use a single post subscription to ensure that we can always see the right post." %>

////
